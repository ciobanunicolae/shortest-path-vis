{"version":3,"sources":["visualizer/node/index.js","algs/dijkstra.js","visualizer/index.js","algs/bfs.js","algs/dfs.js","App.js","index.js"],"names":["Node","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","GridContainer","styled","table","Grid","tbody","Button","button","ButtonsGroup","div","Vizualizer","useState","setGrid","startNodeRow","setStartNodeRow","finishNodeRow","setFinishNodeRow","startNodeCol","setStartNodeCol","finishNodeCol","setFinishNodeCol","mouseIsPressed","setMouseIsPressed","rowCount","colCount","isRunning","setIsRunning","isStartNode","setIsStartNode","isFinishNode","setIsFinishNode","isWallNode","setIsWallNode","currRow","setCurrRow","currCol","setCurrCol","useEffect","getInitialGrid","toggleIsRunnig","rows","cols","initialGrid","currentRow","createNode","distanceToFinishNode","Math","abs","isNode","isGridClear","nodeClassName","document","getElementById","clearGrid","newGrid","slice","visualize","alg","visitedNodes","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","i","setTimeout","animateShortestPath","unshift","getNewGridWithWallToggle","newNode","newMouseIsPressed","onMouseLeave","map","rowId","nodeId","element","handleMouseDown","handleMouseEnter","handleMouseUp","onClick","clearWalls","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b70d1c02.chunk.js","sourcesContent":["import \"./style.css\";\r\nconst Node = (props) => {\r\n    const {col, row, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseUp} = props;\r\n    const extraClassName =isFinish\r\n        ? \"node-finish\"\r\n        :isStart\r\n        ? \"node-start\"\r\n        :isWall\r\n        ? \"node-wall\"\r\n        :\"\";\r\n    return (\r\n            <td\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown={()=>onMouseDown(row,col)}\r\n            onMouseEnter={()=>onMouseEnter(row,col)}\r\n            onMouseUp={()=>onMouseUp()}\r\n            />\r\n     );\r\n}\r\n \r\nexport default Node;","export function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    if (!closestNode.isWall) {\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n","import Node from \"./node\";\r\nimport {useState, useEffect} from \"react\";\r\nimport styled from \"styled-components\";\r\nimport {dijkstra} from '../algs/dijkstra';\r\nimport {dfs} from '../algs/dfs';\r\nimport { bfs } from '../algs/bfs';\r\nconst GridContainer = styled.table`\r\n    margin: 2% auto;\r\n`\r\nconst Grid = styled.tbody`\r\n    white-space: pre;\r\n`\r\nconst Button = styled.button`\r\n    margin: 2px;\r\n    border-radius: 8px;\r\n    border: none;\r\n    background-color: #192736;\r\n    color: white;\r\n    padding: 8px 15px;\r\n    font-size: 1.3rem;\r\n    &:hover{\r\n        cursor: pointer;\r\n        background-color: #576675;\r\n    }\r\n`\r\nconst ButtonsGroup = styled.div`\r\n    display: flex;\r\n    justify-content: center;\r\n`\r\nconst Vizualizer = () => {\r\n    const [grid, setGrid] = useState([]);\r\n    const [startNodeRow, setStartNodeRow] = useState(5);\r\n    const [finishNodeRow, setFinishNodeRow] = useState(5);\r\n    const [startNodeCol, setStartNodeCol] = useState(5);\r\n    const [finishNodeCol, setFinishNodeCol] = useState(15);\r\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n    const [rowCount,setRowCount] = useState(25);\r\n    const [colCount,setColCount] = useState(35);\r\n    const [isRunning, setIsRunning] = useState(false);\r\n    const [isStartNode, setIsStartNode] = useState(false);\r\n    const [isFinishNode, setIsFinishNode] = useState(false);\r\n    const [isWallNode, setIsWallNode] = useState(false);\r\n    const [currRow, setCurrRow] = useState(0);\r\n    const [currCol, setCurrCol] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const grid = getInitialGrid();\r\n        setGrid(grid);\r\n    },[]);\r\n    const toggleIsRunnig = () => {\r\n        setIsRunning(isRunning => !!isRunning);\r\n    }\r\n    const getInitialGrid = (rows = rowCount, cols = colCount)=>{\r\n        const initialGrid = [];\r\n        for (let row = 0; row < rows; ++row){\r\n            const currentRow = [];\r\n            for (let col = 0; col < cols; ++col){\r\n                currentRow.push(createNode(row, col));\r\n            }\r\n            initialGrid.push(currentRow);\r\n        }\r\n        return initialGrid;\r\n    }\r\n    const createNode = (row, col) => {\r\n        return {\r\n            row,\r\n            col,\r\n            isStart:\r\n                row === startNodeRow && col === startNodeCol,\r\n            isFinish:\r\n                row === finishNodeRow && col === finishNodeCol,\r\n            distance: Infinity,\r\n            distanceToFinishNode:\r\n                Math.abs(finishNodeRow - row) + Math.abs(finishNodeCol - col),\r\n            isVisited: false,\r\n            isWall: false,\r\n            previousNode: null,\r\n            isNode: true,\r\n        };\r\n    }\r\n    const handleMouseDown = (row, col) => {\r\n        if (!isRunning) {\r\n            if (isGridClear()) {\r\n                const element = document.getElementById(`node-${row}-${col}`).className;\r\n                if ( element === 'node node-start') {\r\n                    setMouseIsPressed(true);\r\n                    setIsStartNode(true);\r\n                    setCurrRow(row);\r\n                    setCurrCol(col);\r\n                }\r\n                else if (element === 'node node-finish') {\r\n                    setMouseIsPressed(true);\r\n                    setIsFinishNode(true);\r\n                    setCurrRow(row);\r\n                    setCurrCol(col);\r\n                }\r\n                else {\r\n                    const newGrid = getNewGridWithWallToggle(grid, row, col);\r\n                    setGrid(newGrid);\r\n                    setMouseIsPressed(true);\r\n                    setIsWallNode(true);\r\n                    setCurrRow(row);\r\n                    setCurrCol(col);\r\n                }\r\n            } else {\r\n                clearGrid();\r\n            }\r\n        }\r\n    }\r\n    const isGridClear = ()=>{\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n                if (nodeClassName === \"node node-visited\" || nodeClassName === \"node node-shortest-path\") {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    const handleMouseEnter = (row, col) => {\r\n        if (!isRunning) {\r\n            if (mouseIsPressed) {\r\n                const nodeClassName = document.getElementById(`node-${row}-${col}`).className;\r\n                if (isStartNode) {\r\n                    if (nodeClassName !== \"node node-wall\") {\r\n                        const prevStartNode = grid[currRow][currCol];\r\n                        prevStartNode.isStart = false;\r\n                        document.getElementById(`node-${currRow}-${currCol}`,).className = \"node\";\r\n                        setCurrRow(row);\r\n                        setCurrCol(col);\r\n                        const currStartNode = grid[row][col];\r\n                        currStartNode.isStart = true;\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n                    }\r\n                    setStartNodeRow(row);\r\n                    setStartNodeCol(col);\r\n                }\r\n                else if(isFinishNode){\r\n                    if (nodeClassName !== \"node node-wall\") {\r\n                        const prevFinishNode = grid[currRow][currCol];\r\n                        prevFinishNode.isFinish = false;\r\n                        document.getElementById(`node-${currRow}-${currCol}`,).className = 'node';\r\n                        setCurrRow(row);\r\n                        setCurrCol(col);\r\n                        const currFinishNode = grid[row][col];\r\n                        currFinishNode.isFinish = true;\r\n                        document.getElementById(`node-${row}-${col}`,).className = 'node node-finish';\r\n                    }\r\n                    setFinishNodeRow(row);\r\n                    setFinishNodeCol(col);\r\n                }\r\n                else if (isWallNode) {\r\n                    const newGrid = getNewGridWithWallToggle(grid, row, col);\r\n                    setGrid(newGrid);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const handleMouseUp = (row, col) => {\r\n        if (!isRunning) {\r\n            setMouseIsPressed(false);\r\n            if (isStartNode) {\r\n                const newIsStartNode = !isStartNode;\r\n                setIsStartNode(newIsStartNode);\r\n                setStartNodeRow(row);\r\n                setStartNodeCol(col);\r\n            }\r\n            else if (isFinishNode) {\r\n                const newIsFinishNode = !isFinishNode;\r\n                setIsFinishNode(newIsFinishNode);\r\n                setFinishNodeRow(row);\r\n                setFinishNodeCol(col);\r\n            }\r\n            getInitialGrid();\r\n        }\r\n    }\r\n    const handleMouseLeave = () => {\r\n        if (isStartNode) {\r\n            const newIsStartNode = !isStartNode;\r\n            setIsStartNode(newIsStartNode);\r\n            setMouseIsPressed(false);\r\n        }\r\n        else if (isFinishNode) {\r\n            const newIsFinishNode = !isFinishNode;\r\n            setIsFinishNode(newIsFinishNode);\r\n            setMouseIsPressed(false);\r\n        }\r\n        else if (isWallNode) {\r\n            const newIsWallNode = !isWallNode;\r\n            setIsWallNode(newIsWallNode);\r\n            setMouseIsPressed(false);\r\n            getInitialGrid();\r\n        }\r\n    }\r\n    const clearGrid = () => {\r\n        if (!isRunning) {\r\n            const newGrid = grid.slice();\r\n            for (const row of newGrid) {\r\n                for (const node of row) {\r\n                    let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n                    if (\r\n                        nodeClassName !== 'node node-start' &&\r\n                        nodeClassName !== 'node node-finish' &&\r\n                        nodeClassName !== 'node node-wall')\r\n                    {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode = Math.abs(finishNodeRow - node.row) + Math.abs(finishNodeCol - node.col);\r\n                    }\r\n                    if (nodeClassName === 'node node-finish') {\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode = 0;\r\n                    }\r\n                    if (nodeClassName === 'node node-start') {\r\n                        node.isVisited = false;\r\n                        node.distance = Infinity;\r\n                        node.distanceToFinishNode = Math.abs(finishNodeRow - node.row) + Math.abs(setFinishNodeCol - node.col);\r\n                        node.isStart = true;\r\n                        node.isWall = false;\r\n                        node.previousNode = null;\r\n                        node.isNode = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const clearWalls = () => {\r\n        if (!isRunning) {\r\n            const newGrid = grid.slice();\r\n            for (const row of newGrid) {\r\n                for (const node of row) {\r\n                    let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n                    if (nodeClassName === \"node node-wall\") {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                        node.isWall = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const visualize = (alg) => {\r\n        if (!isRunning) {\r\n            clearGrid();\r\n            toggleIsRunnig();\r\n            const startNode = grid[startNodeRow][startNodeCol];\r\n            const finishNode = grid[finishNodeRow][finishNodeCol];\r\n            let visitedNodes;\r\n            switch (alg) {\r\n                case 'Dijkstra':\r\n                    visitedNodes = dijkstra(grid, startNode, finishNode);\r\n                    break;\r\n                case 'BFS':\r\n                    visitedNodes = bfs(grid, startNode, finishNode);\r\n                    break;\r\n                case 'DFS':\r\n                    visitedNodes = dfs(grid, startNode, finishNode);\r\n                    break;\r\n                default:\r\n                    break;\r\n                    //nu ar fi cazul\r\n            }\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            nodesInShortestPathOrder.push(\"end\");\r\n            animate(visitedNodes, nodesInShortestPathOrder);\r\n        }\r\n    }\r\n    const animate=(visitedNodes, nodesInShortestPathOrder)=>{\r\n        for (let i = 0; i <=visitedNodes.length; ++i){\r\n            if (i === visitedNodes.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodes[i];\r\n                const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n                if (\r\n                    nodeClassName !== 'node node-start' &&\r\n                    nodeClassName !== 'node node-finish') {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                    \r\n                }\r\n            }, 10 * i);\r\n        }\r\n    }\r\n    const animateShortestPath = (nodesInShortestPathOrder) => {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; ++i){\r\n            if (nodesInShortestPathOrder[i] === \"end\") {\r\n                setTimeout(() => {\r\n                    toggleIsRunnig();\r\n                }, i * 50);\r\n            }\r\n            else {\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    const nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n                    if (\r\n                        nodeClassName !== 'node node-start' &&\r\n                        nodeClassName !== 'node node-finish') {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n                        \r\n                    }\r\n                }, i * 40);\r\n            }\r\n        }\r\n    }\r\n    const getNodesInShortestPathOrder=(finishNode)=>{\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n            nodesInShortestPathOrder.unshift(currentNode);\r\n\r\n            currentNode = currentNode.previousNode;\r\n        }\r\n        return nodesInShortestPathOrder;\r\n    }\r\n    const getNewGridWithWallToggle = (grid, row, col) => {\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        if (!node.isStart && !node.isFinish && node.isNode) {\r\n            const newNode = {\r\n                ...node,\r\n                isWall: !node.isWall,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        return newGrid;\r\n    }\r\n    const newGrid = grid;\r\n    const newMouseIsPressed = mouseIsPressed;\r\n    return (\r\n        <div>\r\n            <GridContainer\r\n            onMouseLeave={() => handleMouseLeave()}>\r\n                <Grid>\r\n                    {newGrid.map((row, rowId) => {\r\n                        return (\r\n                                <tr key={rowId}>\r\n                                {row.map((node, nodeId) => {\r\n                                   \r\n                                    const { row, col, isFinish, isStart, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeId}\r\n                                            col={col}\r\n                                            isFinish={isFinish}\r\n                                            isStart={isStart}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={newMouseIsPressed}\r\n                                            onMouseDown={(row, col) =>\r\n                                                handleMouseDown(row, col)\r\n                                            }\r\n                                            onMouseEnter={(row, col) =>\r\n                                                handleMouseEnter(row, col)\r\n                                            }\r\n                                            onMouseUp={() => handleMouseUp(row, col)}\r\n                                            row={row}\r\n                                        >\r\n                                        </Node>\r\n                                    );\r\n                                })}\r\n                            </tr>\r\n                        );\r\n                    })}\r\n                </Grid>\r\n            </GridContainer>\r\n            <ButtonsGroup>\r\n            <Button\r\n            onClick={()=>clearGrid()}\r\n            >Sterge Drum</Button>\r\n            <Button\r\n            onClick={()=>clearWalls()}\r\n            >Sterge obstacole</Button>\r\n            <Button\r\n            onClick={()=>visualize(\"Dijkstra\")}\r\n            >Dijkstra</Button>\r\n            <Button\r\n            onClick={()=>visualize(\"BFS\")}\r\n            >BFS</Button>\r\n            <Button\r\n            onClick={()=>visualize(\"DFS\")}\r\n            >DFS</Button>\r\n            </ButtonsGroup>\r\n        </div>\r\n     );\r\n}\r\n \r\nexport default Vizualizer;","export function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","export function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import Visualizer from \"./visualizer\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Visualizer></Visualizer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}